#!/usr/bin/env bash

# declare LOGGING=true
declare -A maps

function log {
  if [[ $LOGGING ]]; then
    echo $@ >&2
  fi
}

# STDIN -> indexed array seeds
# STDIN: seeds: 12 34 56...
function parseSeeds {
  local seedsLabel
  read -d ':' seedsLabel
  read -a seeds
}

function lookUpIndexInMap {
  index="$1"
  map="$2"
  log index $index
  while read range; do
    log checking $index against range $range
    read d s len <<< "$range"
    if (( index >= s && index < s + len )); then
      mappedIndex=$((index - s + d))
      log mapping to $mappedIndex
      echo $mappedIndex
      return
    fi
  done <<< "$map"
  log $index not found in map.  Returning value.
  echo $index
}

function extremeSourcePointsInMap {
  map="$1"
  while read range; do
    read d s len <<< "$range"
    [[ -z $d || -z $s ]] && return
    echo -n $s $((s + len - 1)) ' '
  done <<< "$map"
}


function recursiveLookupSeedIndex {
  seed="$1"
  soil=$(lookUpIndexInMap $seed "${maps['seed:soil']}")
  fertilizer=$(lookUpIndexInMap $soil "${maps['soil:fertilizer']}")
  water=$(lookUpIndexInMap $fertilizer "${maps['fertilizer:water']}")
  light=$(lookUpIndexInMap $water "${maps['water:light']}")
  temperature=$(lookUpIndexInMap $light "${maps['light:temperature']}")
  humidity=$(lookUpIndexInMap $temperature "${maps['temperature:humidity']}")
  location=$(lookUpIndexInMap $humidity "${maps['humidity:location']}")
  echo $location
}

function parseMap {
  # Ignore any empty lines
  local l
  while read l && [[ -z $l ]]; do
    :
  done

  # Header line now in l
  # Parse the headerline to determine source and dest
  log Header line is $l
  if [[ ! $l =~ (.*)-to-(.*)\ map: ]]; then
    if [[ $l ]]; then
      echo "Syntax error reading map" >&2
    fi
    return 1
  fi
  local s=${BASH_REMATCH[1]}
  local d=${BASH_REMATCH[2]}
  local maplabel="$s:$d"

  # Read the ranges
  local map
  local rmap
  until read l && [[ -z $l ]]; do
    echo $l
    [[ $l =~ (.*)\ (.*)\ (.*) ]]
    rl="${BASH_REMATCH[2]} ${BASH_REMATCH[1]} ${BASH_REMATCH[3]}"
    map="$map$l"$'\n'
    rmap="$rmap$rl"$'\n'
  done
  printf 'Parsed map:\n%s' "$map" >&2
  printf 'Parsed rmap:\n%s' "$rmap" >&2
  maps["$s:$d"]="$map"
  maps["$d:$s"]="$marp"
}

function combineMaps {
  from="$1"
  via="$2"
  to="$3"
  map1="${maps[$from:$via]}"
  rmap1="${maps[$via:$from]}"
  map2="${maps[$via:$to]}"
  viaExtremes=$(extremeSourcePointsInMap "$map2")
  fromExtremes=$(extremeSourcePointsInMap "$map1")
  log via extreme points: $viaExtremes
  for i in $viaExtremes; do
    ri=$(lookUpIndexInMap "$i" "$rmap1")
    echo $ri
  done
  echo "${fromExtremes// /$'\n'}"
}

parseSeeds
echo Seeds: ${seeds[@]}

while parseMap; do : ; done
echo parsed all maps

echo -n extremeSourcePointsInMap seed soil 
extremeSourcePointsInMap "${maps["seed:soil"]}"
echo

sourcepoints=$(combineMaps "seed" "soil" "fertilizer")
echo $sourcePoints
echo
echo sorted:
sort -n <<<"$sourcepoints"

# echo
# minLocation=$(recursiveLookupSeedIndex "${seeds[0]}")
# seedsLength=${#seeds[@]}
# echo seedsLength $seedsLength
# for ((i=0; i < seedsLength; i+=2)); do
#   declare -i s=${seeds[i]}
#   declare -i len=${seeds[i+1]}
#   for ((j=s; j < s + len; j++)); do
#     location=$(recursiveLookupSeedIndex $j)
#     echo seed $j location $location
#     if (( location < minLocation )); then
#       minLocation=$location
#     fi
#   done
# done
# echo MinLocation $minLocation
#
#
#
