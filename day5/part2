#!/usr/bin/env bash

# declare LOGGING=true

declare -A maps

function log {
  if [[ $LOGGING ]]; then
    echo $@ >&2
  fi
}

# arg1: name of variable to print
function printVar {
  declare -n varRef
  varRef=$1
  local varName=$1
  printf '%s=%s\n' "$varName" "$varRef"
}

function sortLineUnique {
  local sl
  # Remove extra spaces. Extra spaces turns into blank lines which causes 0 to
  # be removed with sort -n -u
  l=$(echo $1)
  sl=$(sort -n -u <<< "${l// /$'\n'}")
  echo $sl
}

# STDIN -> indexed array seeds
# STDIN: seeds: 12 34 56...
function parseSeeds {
  local seedsLabel
  read -d ':' seedsLabel
  read -a seeds
}

function lookUpIndexInMap {
  local index="$1"
  local map="$2"
  log index $index
  while read range; do
    log checking $index against range $range
    read d s len <<< "$range"
    if (( index >= s && index < s + len )); then
      mappedIndex=$((index - s + d))
      log mapping to $mappedIndex
      echo -n $mappedIndex
      return
    fi
  done <<< "$map"
  log $index not found in map.  Returning value.
  echo -n $index
}

function lookUpIndicesInMap {
  local indices="$1"
  local map="$2"
  for i in $indices; do
    lookUpIndexInMap "$i" "$map"
    echo -n ' '
  done
}

function extremeSourcePointsInMap {
  map="$1"
  log extremeSourcePointsInMap "$map"
  while read range; do
    log range "$range"
    read d s len <<< "$range"
    [[ -z $d || -z $s ]] && return
    # if ((len > 1)); then
      echo -n $s $((s + len - 1)) ' '
    # else
    #   if ((len == 1)); then
    #     echo -n $s ' '
    #   else
    #     echo Error len is 0! >2
    #     exit 1
    #   fi
    # fi
    log adding points $s $((s + len - 1)) ' '
  done <<< "$map"
}


function recursiveLookupSeedIndex {
  seed="$1"
  soil=$(lookUpIndexInMap $seed "${maps['seed:soil']}")
  fertilizer=$(lookUpIndexInMap $soil "${maps['soil:fertilizer']}")
  water=$(lookUpIndexInMap $fertilizer "${maps['fertilizer:water']}")
  light=$(lookUpIndexInMap $water "${maps['water:light']}")
  temperature=$(lookUpIndexInMap $light "${maps['light:temperature']}")
  humidity=$(lookUpIndexInMap $temperature "${maps['temperature:humidity']}")
  location=$(lookUpIndexInMap $humidity "${maps['humidity:location']}")
  echo $location
}

function parseMap {
  # Ignore any empty lines
  local l
  while read l && [[ -z $l ]]; do
    :
  done

  # Header line now in l
  # Parse the headerline to determine source and dest
  log Header line is $l
  if [[ ! $l =~ (.*)-to-(.*)\ map: ]]; then
    if [[ $l ]]; then
      echo "Syntax error reading map" >&2
    fi
    return 1
  fi
  local s=${BASH_REMATCH[1]}
  local d=${BASH_REMATCH[2]}
  local maplabel="$s:$d"

  # Read the ranges
  local map
  local rmap
  until read l && [[ -z $l ]]; do
    echo $l
    [[ $l =~ (.*)\ (.*)\ (.*) ]]
    rl="${BASH_REMATCH[2]} ${BASH_REMATCH[1]} ${BASH_REMATCH[3]}"
    map="$map$l"$'\n'
    rmap="$rmap$rl"$'\n'
  done
  printf 'Parsed map:\n%s' "$map" >&2
  printf 'Parsed rmap:\n%s' "$rmap" >&2
  maps["$s:$d"]="$map"
  maps["$d:$s"]="$rmap"
}

# lowerA upperA lowerB upperB ->
# lowerA-1 lowerA upperA upperA+1 lowerB-1 lowerB upperB upperB+1 ...
function extend {
  mapfile -d ' ' elements <<< "$1"
  for ((i = 0; i < ${#elements[@]}; i+=2)); do
    echo -n $((${elements[i]}-1)) ${elements[i]} ${elements[i+1]} $((${elements[i+1]}+1)) ' ' 
  done
}

function combineMaps {
  local from="$1"
  local via="$2"
  local to="$3"
  map1="${maps[$from:$via]}"
  rmap1="${maps[$via:$from]}"
  map2="${maps[$via:$to]}"
  viaExtremes=$(extremeSourcePointsInMap "$map2")
  viaExtremes=$(sortLineUnique "$viaExtremes")
  viaExtremesInFrom=$(lookUpIndicesInMap "$viaExtremes" "$rmap1")
  # The backprojected internals might "interupt" original ranges so add points
  # outside of the backprojected ranges
  extendedViaExtremesInFrom=$(extend "$viaExtremesInFrom")
  fromExtremes=$(extremeSourcePointsInMap "$map1")
  extendedFromExtremes=$(extend "$fromExtremes")
  allFromExtremes="$extendedFromExtremes $extendedViaExtremesInFrom"
  sortedAllFromExtremes=$(sortLineUnique "$allFromExtremes")
  # printVar "viaExtremes" >&2
  # printVar "viaExtremesInFrom" >&2
  # printVar "fromExtremes" >&2
  # printVar "extendedFromExtremes" >&2
  # printVar "allFromExtremes" >&2
  # printVar "sortedAllFromExtremes" >&2
  mapfile -d ' ' fromArray <<< "$sortedAllFromExtremes"
  declare -i count=${#fromArray[@]}
  declare -i index
  cmap=""
  rcmap=""
  for (( i = 0; i < count-1; i+=1 )); do
    len=$((fromArray[i+1] - fromArray[i]))
    fromIndex=${fromArray[$i]}
    viaIndex=$(lookUpIndexInMap "$fromIndex" "$map1")
    toIndex=$(lookUpIndexInMap "$viaIndex" "$map2")
    # printVar i
    # printVar len
    # printVar from
    # printVar via
    # printVar to
    cmap="$toIndex $fromIndex $len"$'\n'"$cmap"
    rcmap="$fromIndex $toIndex $len"$'\n'"$rcmap"
  done
  maps["$from:$to"]="$cmap"
  maps["$to:$from"]="$rcmap"
}

function valuesWithinMinMax {
  local values="$1"
  local min="${2% *}"
  local max="${2#* }"
  for v in $values; do
    (( v >= min && v <= max )) && echo -n $v ' '
  done
}

function processSeeds {
  sourcePoints=$(extremeSourcePointsInMap "$cmap")
  sourcePoints=$(sortLineUnique "$sourcePoints")
  printVar sourcePoints
  declare -i minLocation
  for (( i=0; i<${#seeds[@]}; i+=2)); do
    minmax="${seeds[i]} $((${seeds[i]} + ${seeds[i+1]} - 1))"
    points="$(valuesWithinMinMax "$sourcePoints" "$minmax")"
    points="$minmax $points"
    printVar minmax
    printVar points
    for p in $points; do
      l=$(lookUpIndexInMap "$p" "$cmap")
      if [[ ! -v minLocation ]]; then
        minLocation=l
      else
        if (( l < minLocation )); then
          minLocation=l
        fi
      fi
      printVar l
    done
  done
  printVar minLocation
}

parseSeeds
echo Seeds: ${seeds[@]}

while parseMap; do : ; done
echo parsed all maps

combineMaps "seed" "soil" "fertilizer"
echo 1
combineMaps "seed" "fertilizer" "water"
echo 2
combineMaps "seed" "water" "light"
echo 3
combineMaps "seed" "light" "temperature"
echo 4
combineMaps "seed" "temperature" "humidity"
echo 5
combineMaps "seed" "humidity" "location"
echo 6
cmap=${maps["seed:location"]}
printVar cmap

processSeeds
exit 0

for (( i=0; i<99; i+=1 )); do
  f=$(lookUpIndexInMap "$i" "$cmap")
  r=$(recursiveLookupSeedIndex "$i")
  echo seed $i is mapped to water $f via combined map $r via recursive lookup
done


# sourcepoints=$(combineMaps "seed" "soil" "fertilizer")
# echo $sourcePoints
# echo
# echo sorted:
# sort -n <<<"$sourcepoints"


# echo
# minLocation=$(recursiveLookupSeedIndex "${seeds[0]}")
# seedsLength=${#seeds[@]}
# echo seedsLength $seedsLength
# for ((i=0; i < seedsLength; i+=2)); do
#   declare -i s=${seeds[i]}
#   declare -i len=${seeds[i+1]}
#   for ((j=s; j < s + len; j++)); do
#     location=$(recursiveLookupSeedIndex $j)
#     echo seed $j location $location
#     if (( location < minLocation )); then
#       minLocation=$location
#     fi
#   done
# done
# echo MinLocation $minLocation
#
#
#

# Seed->soil map
#   50-97 -> 52-99
#   98-99 -> 50-51
# soil-to-fertilizer map
#   0-14  -> 39-53
#   15-51 -> 0-36
#   52-53 -> 37-38
# soil (via) extremes 0 14 15 51 52 53
# soil (via)->seed (from) extremes 0->0 14->14 15->15 51->99 52->50 53->51
# soil (via)->seed (from) extremes 0 14 15 99 50 51
# Seed 52 -> soil 54 -> 39
#
# backProjected fromExtremes: 0 14 15  50 51 99
# original fromExtremes: 50 97 98 99
#
#
#
#
